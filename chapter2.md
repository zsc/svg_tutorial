# 第 2 章：SVG 核心语法：从 XML 到几何表达

## 1. 开篇段落

欢迎深入 SVG（Scalable Vector Graphics）的内核。在绝大多数计算机视觉（CV）任务中，图像是像素矩阵（Raster），但在我们的 SVG-MLLM 项目中，**图像是代码**。

对于人类设计师，SVG 是 Illustrator 或 Figma 画板上的图形；但对于大模型，SVG 首先是一串**文本序列（Sequence of Tokens）**，其次是一棵**结构化树（DOM Tree）**，最后才是通过渲染引擎呈现的**视觉信号**。

本章的目标不仅仅是教你“怎么写 SVG”，而是教你“如何从机器视角的理解 SVG”。我们需要解构 SVG 如何通过 XML 标签定义画布空间，如何通过数学指令描述几何拓扑，以及这些表达方式对模型训练意味着什么（例如：为什么相对坐标比绝对坐标更有利于模型学习形状的泛化？为什么贝塞尔曲线的控制点预测是生成的难点？）。如果你希望模型能生成可编辑、可渲染、结构合法的矢量图，就必须先掌握这门“几何语言”的语法规则。

---

## 2. 文字论述

### 2.1 SVG 文档结构：画布、视口与归一化

SVG 本质上是一个 XML 文档。对于 MLLM 而言，第一步就是理解“世界在哪里”。

#### Viewport（视口）与 ViewBox（可视区）的博弈
这是 SVG 中最核心的坐标映射概念，也是数据预处理中最容易出错的环节。

*   **Viewport (物理窗口)**：通常由 `<svg width="800px" height="600px">` 定义。它决定了浏览器或渲染引擎在屏幕上开辟多大的矩形区域。对于模型生成而言，这通常是不重要的，因为矢量图可以无限缩放。
*   **ViewBox (逻辑世界)**：由 `<svg viewBox="min-x min-y width height">` 定义。这是模型真正“生活”的坐标系。

**关键概念：归一化（Normalization）**
在训练 SVG 模型时，我们通常不希望模型去预测任意范围的浮点数（如 `1234.56`）。我们希望将所有数值限制在一个固定的范围（如 0-1 或 0-1024）。因此，理解 `viewBox` 是进行数据清洗的第一步。

```text
    [ 浏览器 / 屏幕物理像素区域 (Viewport) ]
    +-------------------------------------------------------+
    |  (0,0) 物理原点                                        |
    |   +-----------------------------------------------+   |
    |   |  SVG 画布 (viewBox="0 0 100 100")              |   |
    |   |                                               |   |
    |   |   逻辑坐标 (50, 50) 在这里  -------->  X       |   |
    |   |   虽然只有 100 单位宽，但它被映射到            |   |
    |   |   整个屏幕区域。对于模型，它只需输出 50。      |   |
    |   |                                               |   |
    |   +-----------------------------------------------+   |
    |                                                       |
    +-------------------------------------------------------+
```

> **Rule-of-Thumb**: 在将 SVG 喂给模型前，务必重写 `viewBox` 为标准正方形（如 `0 0 24 24` 或 `0 0 1024 1024`），并重新缩放内部所有的路径坐标。这能极大降低模型对“空间尺度”的学习负担。

### 2.2 基本图元 (Primitives)：几何的“高级词汇”

SVG 提供了一组预定义的几何形状。虽然它们都可以用 `<path>` 来表示，但保留图元标签对 MLLM 具有极高的语义价值。

1.  **Rect (矩形)**: `<rect x="10" y="10" width="50" height="50" rx="5" />`
    *   **语义**: 模型输出这个标签，意味着它明确知道这是一个“盒子”，且可能有圆角 (`rx/ry`)。
2.  **Circle (圆)**: `<circle cx="50" cy="50" r="20" />`
    *   **语义**: 定义圆只需 3 个参数。如果转为 `<path>`，则需要 4 段贝塞尔曲线（约 24 个参数），不仅序列变长，而且模型很难精确画出完美的圆。
3.  **Line / Polyline / Polygon**: 线段与多边形。
    *   **语义**: `polygon` 隐含了“闭合”的几何约束，而 `polyline` 是开放的。

> **模型设计决策**: 在构建 Tokenizer 时，是否将 `rect` 转换为 `path`？
> *   **转换派**: 统一词表，所有几何都是 path，模型只需学一种语法。
> *   **保留派**: 保留高级语义，生成的 SVG 更容易被人类编辑（Human-readable）。
> *   **结论**: 现代趋势倾向于**保留**。因为这属于“结构化思维”的一部分。

### 2.3 `<path>` 语言：几何的“汇编语言”

`<path>` 是 SVG 的灵魂。其 `d` (data) 属性包含了一套极其紧凑的绘图指令微语言。这是生成式模型最难攻克的部分，因为它是一个**状态机（State Machine）**。

#### 2.3.1 绝对坐标 (Upper case) vs. 相对坐标 (Lower case)

*   **绝对指令 (如 `M 100 100 L 200 100`)**: 坐标是相对于原点的。
    *   *优点*: 即使前面的点预测错了，当前点的位置依然是固定的（误差不累积）。
    *   *缺点*: 形状与位置强绑定。一个在左上角的正方形和在右下角的正方形，其坐标序列完全不同，模型难以学到“正方形”这个形状的通用表示。
*   **相对指令 (如 `m 100 100 l 100 0`)**: 坐标是相对于“笔触当前位置”的增量。
    *   *优点*: **平移不变性（Translation Invariance）**。无论正方形在哪，画它的指令（`l 100 0 l 0 100 l -100 0 z`）都是一样的。这极大地帮助了模型的泛化。
    *   *缺点*: **误差累积**。如果模型在第一步偏了 1 像素，后面所有的点都会偏 1 像素。

#### 2.3.2 贝塞尔曲线 (Bezier Curves) —— 矢量图的基石

这是 SVG 生成中最具挑战性的部分。

*   **三次贝塞尔 (`C / c`)**: 需要 4 个点：起点（当前笔触）、控制点1、控制点2、终点。
    *   **直觉**: 想象一条橡皮筋连接起点和终点。控制点1像磁铁一样吸引起点的切线方向，控制点2吸引终点的切线方向。
*   **二次贝塞尔 (`Q / q`)**: 只有 1 个控制点。计算简单，但表达复杂曲线能力弱。
*   **平滑连接 (`S / s`, `T / t`)**:
    *   这是为了保证曲线在连接处**C1 连续（切线平滑）**。
    *   `S x2 y2 x y`: 这里省略了第一个控制点，它被默认计算为“上一段曲线第二个控制点的中心对称点”。
    *   **MLLM 难点**: `S` 指令意味着模型不仅要看当前的输入，还要“回忆”起上一段曲线的几何特征。这强依赖于 Transformer 的 Attention 机制。

```text
       (Start) P0          P1 (Control Point 1)
              o-----------o
              |            \
              |             \      (The Curve)
              |              \   . . . . . .
              |               \ .           .
     Tangent  |                .             .
     Direction|               .               .
                              .                o P2 (Control Point 2)
                             .                /
                            .                /
                           o----------------o
                       (End) P3
```

#### 2.3.3 弧线 (`A / a`) 的噩梦

`A rx ry rot large-arc-flag sweep-flag x y`
弧线指令是参数最多的指令，包含两个布尔标志位（大弧/小弧，顺时针/逆时针）。
*   **Gotchas**: `A` 指令非常难以训练。大多数 SVG 深度学习工作（如 DeepSVG, Im2Vec）在预处理阶段都会**将所有 Arc 转换为近似的 Cubic Bezier Curves**。这是一个标准的 Rule-of-Thumb。

### 2.4 变换系统 (Coordinate Transforms)

SVG 允许在组 (`<g>`) 或元素级别应用变换：`translate`, `scale`, `rotate`, `skewX/Y`, `matrix`。

*   **嵌套问题**: `<g transform="rotate(45)"><rect transform="translate(10,0)" .../></g>`
*   **模型视角**: 这种嵌套结构要求模型具备极强的空间想象力（执行矩阵乘法）。
*   **工程策略**: 为了降低学习难度，通常在训练数据预处理（Canonicalization）阶段，将所有变换**展开（Flatten/Bake）**应用到路径本身的坐标点上。
    *   *例外*: 如果你的目标是“生成可编辑的 SVG”，那么保持变换结构是有意义的，但这显著增加了难度。

### 2.5 样式系统：几何与视觉的分离

SVG 的强大之处在于内容（Path）与表现（Style）的分离。

*   **Fill (填充)**: 颜色、渐变 (`<linearGradient>`, `<radialGradient>`)、图案 (`<pattern>`)。
*   **Stroke (描边)**: `stroke`, `stroke-width`, `stroke-linecap` (端点形状), `stroke-linejoin` (拐角形状), `stroke-dasharray` (虚线)。
*   **Fill-Rule (填充规则)**:
    *   `nonzero` (默认): 基于射线法和路径方向（顺/逆时针）判定内部。
    *   `evenodd`: 仅仅计算射线穿过路径的次数，奇数为内，偶数为外。
    *   **陷阱**: 如果模型生成的路径方向（winding order）混乱（一会顺时针一会逆时针），在 `nonzero` 规则下会出现意想不到的“镂空”或“填实”错误。

---

## 3. 本章小结

1.  **代码即图像**: SVG 是通过 XML 文本描述的矢量图。对 MLLM 来说，这是一个序列生成任务。
2.  **空间归一化**: `viewBox` 是逻辑坐标系，训练前必须将数据归一化到固定范围（如 0-1 或 0-256）。
3.  **Path 是核心**: 理解 `M`, `L`, `C` 指令是理解 SVG 的关键。贝塞尔曲线通过控制点定义形状，这是参数化建模的重点。
4.  **状态机特性**: SVG 解析是上下文相关的（Context-sensitive）。当前点的坐标往往依赖于上一个点（相对坐标）或上一条曲线（S 指令）。
5.  **预处理黄金法则**:
    *   将所有非 Path 图元（Rect/Circle）视任务需求决定去留。
    *   将 `Arc` 指令近似为 `Cubic Bezier`。
    *   将嵌套的 `Transform` 烘焙进坐标点。
    *   统一坐标精度（量化）。

---

## 4. 练习题

### 基础题 (熟悉材料)

1.  **ViewBox 计算**: 一个 SVG 定义为 `<svg width="200" height="200" viewBox="0 0 100 100">`。
    如果在坐标 `(50, 50)` 处画一个点，请问它在屏幕上的物理位置是在 SVG 区域的中心，还是右下角？
    *   <details><summary>Hint</summary>关注 viewBox 的中点是哪里。</details>
    *   <details><summary>Answer</summary>中心。逻辑坐标 (50,50) 是 100x100 逻辑空间的中点，映射到物理空间也是中点。</details>

2.  **Path 笔触追踪**: 给定指令序列 `M 10 10 h 20 v 20 h -20 z` (注意大小写混合)。请描述这是一个什么形状，以及它的各个顶点坐标。
    *   <details><summary>Hint</summary>h/v 是水平/垂直移动，小写是相对坐标。</details>
    *   <details><summary>Answer</summary>这是一个边长为 20 的正方形。顶点依次为：(10,10) -> (30,10) -> (30,30) -> (10,30) -> 回到 (10,10)。</details>

3.  **贝塞尔控制点**: 在指令 `C 10 10 90 10 100 0` 中，起点是 (0,0)。请问这条曲线在起点的切线斜率大致是多少？
    *   <details><summary>Hint</summary>起点的切线方向由起点和第一个控制点 (10,10) 决定。</details>
    *   <details><summary>Answer</summary>切线方向是 (0,0) 指向 (10,10)，即 45度角，斜率为 1。</details>

4.  **XML 结构**: 写出一个包含红色填充、黑色描边、描边宽度为 2 的圆形的 SVG 代码片段。
    *   <details><summary>Hint</summary>使用 circle 标签和 style 属性。</details>
    *   <details><summary>Answer</summary>`<circle cx="50" cy="50" r="20" fill="red" stroke="black" stroke-width="2" />`</details>

### 挑战题 (开放性思考)

5.  **Transformer 的视野**: 为什么说使用“相对坐标”训练 Transformer 可能比“绝对坐标”更难收敛，但泛化性更好？请从 Attention 机制和误差传播的角度思考。
    *   <details><summary>Hint</summary>绝对坐标让每个 token 独立对应位置；相对坐标让 token 之间产生强依赖。</details>
    *   <details><summary>Answer</summary>使用相对坐标时，第 N 个点的绝对位置依赖于前 N-1 个点的累加和。Transformer 必须学会这种累加运算（这对 Attention 来说并不直观）。一旦序列前部出现预测误差，后续整个形状会“漂移”出画面。但如果学会了，模型就掌握了“形状”本身的特征，而不受位置干扰，从而能画出任何位置的物体。</details>

6.  **S 指令的数学含义**: 如果我们将所有的 `S` 指令都显式展开为 `C` 指令（补全那个隐含的控制点），这对模型的训练是有利还是有弊？
    *   <details><summary>Hint</summary>Token 数量 vs. 推理难度。</details>
    *   <details><summary>Answer</summary>有利有弊。弊端是 Token 序列变长了（多了两个坐标数）。利益是消除了“隐式依赖”，模型不需要去计算“中心对称点”，降低了单步推理的数学难度。通常建议展开，让显式信息最大化。</details>

7.  **Tokenization 策略**: 如果画布是 256x256。我们有两个方案：
    A. 将坐标 `128` 视为文本 `"1", "2", "8"` 三个 token。
    B. 将坐标 `128` 视为一个整数 token `<coord_128>`。
    哪种更适合 SVG 生成？为什么？
    *   <details><summary>Hint</summary>词表大小 (Vocabulary Size) 和序列长度 (Context Length)。</details>
    *   <details><summary>Answer</summary>方案 B (量化/Binning) 通常更好。SVG 坐标是数值意义，而非语义文本。方案 A 让序列变得极长，且模型很难理解 "1" 后面的 "2" 是十位。方案 B 虽然增加了词表大小（如增加 256 个 token），但显著缩短了序列长度，且让模型将位置视为一种分类问题，效果通常优于纯文本回归。</details>

8.  **不可见性问题**: 如果一个 `<path>` 的 `d` 属性完全正确，`stroke` 是 red，`stroke-width` 是 5，但渲染出来依然什么都没有。除了 `opacity` 和 `display`，还有可能是 SVG 的哪个父级属性导致的？
    *   <details><summary>Hint</summary>关于定义的复用。</details>
    *   <details><summary>Answer</summary>这个 path 可能被定义在 `<defs>` 标签内。`<defs>` 中的元素不会直接渲染，除非被 `<use>` 引用。</details>

---

## 5. 常见陷阱与错误 (Gotchas)

在处理 SVG 数据集和构建模型时，以下是 90% 的开发者会踩的坑：

1.  **科学计数法的诅咒**
    *   **现象**: 解析器崩溃或模型输出乱码。
    *   **原因**: 许多矢量软件（如 Illustrator）会为了压缩体积，将 `0.00001` 输出为 `1e-5`。普通的文本 Tokenizer 可能会把它切分成 `1`, `e`, `-`, `5`，导致模型困惑。
    *   **对策**: 在预处理脚本中，强制将所有科学计数法转换为浮点数或定点小数格式。

2.  **逗号与空格的随意性**
    *   **现象**: 正则表达式无法正确分割坐标。
    *   **原因**: SVG 标准规定，`M 10 20`，`M10,20`，`M 10, 20`，`M10.5.5`（如果是小数，甚至可以省略空格）都是合法的。
    *   **对策**: 不要自己写 Regex 解析 path string。使用 `svgpathtools` 或 `svgelements` 库解析成对象，再重新序列化为标准格式（例如：命令和数字间统一用空格，坐标对间统一用逗号）。

3.  **隐式 L 指令**
    *   **现象**: `d="M 10 10 20 20 30 30"`。
    *   **原因**: 标准允许在 `M` 后面跟随多组坐标，后续的坐标会被隐式视为 `L`（画线）。
    *   **对策**: Canonicalization 必须将隐式指令显式化，变成 `M 10 10 L 20 20 L 30 30`，否则模型会学到混乱的语法。

4.  **Z 指令后的位移**
    *   **现象**: 路径闭合后，下一条指令也是画线，结果飞线了。
    *   **原因**: `Z` 指令会将“当前点”重置为子路径的起点。如果在 `Z` 之后紧跟相对坐标指令（如 `l 10 10`），它是基于起点的位移，而不是基于 Z 之前的点的位移。

5.  **Fill-Rule 的默认值陷阱**
    *   **现象**: 环形图标（Donut shape）中间的洞被填满了。
    *   **原因**: SVG 默认 `fill-rule="nonzero"`。如果你的数据集中包含大量依靠 `evenodd` 渲染的图标，但你没有显式把这个属性喂给模型，模型默认用 nonzero 渲染就会出错。
    *   **对策**: 尽可能在数据清洗阶段，利用布尔运算库（如 Skia PathOps）将 `evenodd` 的路径转换为几何上等价的 `nonzero` 路径（通常涉及改变内孔洞的绕转方向）。
