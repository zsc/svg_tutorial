<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第 7 章：渲染引擎与训练闭环：resvg 与 PyTorch-SVGRender</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">SVG-MLLM：基于 SVG 的多模理解生成一体化大模型（中文教程）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 1 章：从 SVG 到 SVG-MLLM：问题定义与路线图</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 2 章：SVG 核心语法：从 XML 到几何表达</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 3 章：SVG 与 Web 联动：DOM、CSS、JS 与 three.js 协同</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[第 4 章：Web SVG 数据工程：采集、清洗、规范化与对齐](chapter4.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[第 5 章：传统矢量化与图像追踪（Image Tracing）算法](chapter5.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 6 章：SVG 结构化表示：从文本到 Token / AST / 图</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 7 章：渲染引擎与训练闭环：resvg 与 PyTorch-SVGRender</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 8 章：DeepSVG：学习式 SVG 表示与生成基线</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 9 章：从 Stroke 到 Path：Sketch 系列思想与贝塞尔生成</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 10 章：现代 SVG 工作谱系综述：StarVector、OmniSVG、InternSVG 等</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 11 章：SVG-MLLM 架构设计：理解与生成一体化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 12 章：训练流程：预训练、指令微调、偏好对齐与有效性保障</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 13 章：评测体系：像素、结构、语义与可编辑性</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 14 章：SVG Animation：时间维度、交互与可控运动生成</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 15 章：应用专题 I：字体、字形生成与排版 (SVG × Typography)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 16 章：应用专题 II：BEV 矢量地图与系统落地（SVG × Map/Driving）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="7-resvg-pytorch-svgrender">第 7 章：渲染引擎与训练闭环：resvg 与 PyTorch-SVGRender</h1>
<h2 id="1">1. 开篇段落</h2>
<p>在构建多模态大模型（MLLM）时，文本（SVG 代码）与视觉（图像）之间的鸿沟是最大的挑战。对于一个纯语言模型来说，<code>&lt;path d="M10 10 L50 50" /&gt;</code> 是一串字符序列；而对于人类和视觉编码器来说，它是一条倾斜的黑线。如果我们的 SVG-MLLM 只能“背诵”代码而无法“想象”画面，它就无法处理复杂的空间推理任务，也无法进行基于视觉反馈的自我修正。</p>
<p><strong>渲染引擎（Rendering Engine）</strong> 正是连接这两个世界的桥梁。本章将不再把渲染仅仅看作最后一步的展示工具，而是将其视为<strong>训练循环中的核心可微组件</strong>。我们将深入剖析两类截然不同的渲染器：以 <strong><code>resvg</code></strong> 为代表的“真理标准”（高精度、静态、CPU），和以 <strong><code>PyTorch-SVGRender</code> (DiffVG)</strong> 为代表的“可微导师”（近似、动态、GPU、可反传梯度）。</p>
<p>通过本章的学习，你将掌握如何建立 <code>SVG 参数 → 渲染 → 视觉编码器 → Loss → 梯度更新</code> 的完整闭环，这是让模型真正“看懂”它自己写的代码的必经之路。</p>
<hr />
<h2 id="2">2. 核心论述</h2>
<h3 id="21-mllm">2.1 渲染在 MLLM 中的战略地位</h3>
<p>在传统 NLP 任务中，Token 是最小单位。但在 SVG-MLLM 中，我们面临三种模态表示的流转：</p>
<ol>
<li><strong>Symbolic (符号)</strong>: XML 文本，离散的，适合 LLM 生成。</li>
<li><strong>Geometric (几何)</strong>: 贝塞尔曲线控制点、颜色数值，连续的，适合数值优化。</li>
<li><strong>Visual (视觉)</strong>: 像素矩阵，适合 ViT/CLIP 提取特征。</li>
</ol>
<p>渲染引擎负责将 2 转化为 3。在训练架构设计中，渲染器通常出现在以下两个位置：</p>
<ul>
<li><strong>前向数据工厂 (Forward Data Factory)</strong>: 在预训练阶段，我们需要海量“SVG 代码 - 渲染图像”对。这需要一个<strong>极度精准、符合 W3C 标准</strong>的渲染器，确保模型学到的是正确的对应关系。这是 <code>resvg</code> 的战场。</li>
<li><strong>后向反馈回路 (Backward Feedback Loop)</strong>: 在微调或对齐阶段，我们希望模型根据“画得像不像”来调整参数。这需要一个<strong>可求导</strong>的渲染器，让 Loss 能够穿过像素，反传到控制点坐标上。这是 <code>PyTorch-SVGRender</code> 的战场。</li>
</ul>
<div class="codehilite"><pre><span></span><code>[  LLM / Policy  ]
       | (输出)
       v
[  SVG 代码/参数  ]  ----(1. resvg: 生成 GT / 评测)----&gt; [ 完美图像 ]
       |
       | (2. DiffRender: 训练流)
       v
[  可微光栅化  ]
       |
       v
[  Tensor图像  ]  &lt;----(对比 Loss)----&gt; [ 目标图像 / CLIP文本 ]
       |
    (梯度反传)
       |
       v
[ 更新几何参数 ]
</code></pre></div>

<h3 id="22-resvg">2.2 工业级标准：深入 resvg</h3>
<p>为什么不能随便用一个 Python 的 <code>cairo</code> 绑定或者 <code>matplotlib</code> 来渲染 SVG？</p>
<p><strong>SVG 标准的复杂性陷阱</strong>：SVG 并不是简单的画线。它包含复杂的 CSS 层级继承、视口变换（ViewBox）、混合模式（Blend Modes）、滤镜（Filters）以及路径裁剪（ClipPath）。大多数轻量级库只支持 SVG 的一个微小合集。如果模型生成的 SVG 包含这些高级特性，而渲染器不支持，模型就会产生幻觉（Hallucination）——它认为自己画对了，渲染器却显示空白。</p>
<p><strong>resvg 的优势</strong>：</p>
<ul>
<li><strong>基于 Rust</strong>：内存安全，性能极高。</li>
<li><strong>Chrome 级对齐</strong>：其核心目标是“渲染结果与 Chrome 像素级一致”。在做 MLLM 数据清洗时，这是至关重要的。</li>
<li><strong>静态库集成</strong>：虽然它是 Rust 编写的，但可以通过 Python binding（如 <code>resvg-py</code>）轻松调用。</li>
</ul>
<blockquote>
<p><strong>Rule of Thumb (工程经验)</strong>：在进行大规模数据预处理时，<strong>永远先用 resvg 渲染一遍</strong>。如果渲染结果是纯白、纯黑或尺寸异常（如 1x1 像素），直接丢弃该数据。不要试图让模型学习无法被标准引擎渲染的代码。</p>
</blockquote>
<h3 id="23">2.3 可微渲染的数学直觉：为什么像素可以求导？</h3>
<p>这是本章最硬核的概念。
标准的<strong>光栅化（Rasterization）</strong>是一个离散过程：我们要决定屏幕上的像素 $P(x,y)$ 是否在三角形 $T$ 内部。这通常用一个指示函数 $\mathbb{I}(P \in T)$ 表示。</p>
<ul>
<li>如果在内部，像素值为颜色 $C$。</li>
<li>如果在外部，像素值为背景色 $B$。</li>
</ul>
<p>这个阶跃函数（Step Function）在边缘处不可导（导数为无穷大），在其他地方导数为 0。这意味着你无法通过查看像素颜色来告诉三角形“向右移动一点点”。</p>
<p><strong>可微渲染（PyTorch-SVGRender / DiffVG）的解决方案</strong>：
它引入了<strong>抗锯齿（Anti-aliasing）作为平滑函数</strong>。它不再问“像素是否在三角形内”，而是问“像素距离三角形边缘有多近”。
像素颜色 $I$ 计算公式变为：
$$ I = \alpha(d) \cdot C + (1 - \alpha(d)) \cdot B $$
其中 $\alpha(d)$ 是覆盖率函数，通常与像素中心到边缘的符号距离 $d$ 有关。</p>
<ul>
<li>当三角形边缘移动时，距离 $d$ 发生微小变化。</li>
<li>覆盖率 $\alpha(d)$ 随之平滑变化。</li>
<li>像素颜色 $I$ 随之变化。</li>
<li><strong>梯度打通！</strong> $\frac{\partial Loss}{\partial I} \rightarrow \frac{\partial I}{\partial \alpha} \rightarrow \frac{\partial \alpha}{\partial d} \rightarrow \frac{\partial d}{\partial \text{Vertex}}$。</li>
</ul>
<h3 id="24">2.4 训练闭环设计：三种范式</h3>
<p>在 SVG-MLLM 开发中，你可以构建三种不同深度的闭环：</p>
<ol>
<li>
<p><strong>参数优化环 (Parameter Optimization Loop)</strong>：</p>
<ul>
<li><strong>输入</strong>：一张目标位图。</li>
<li><strong>过程</strong>：初始化一组随机 SVG 路径，冻结拓扑结构，利用 <code>PyTorch-SVGRender</code> 只优化控制点坐标和颜色。</li>
<li><strong>应用</strong>：图像矢量化（Image Tracing/Vectorization）。</li>
</ul>
</li>
<li>
<p><strong>生成微调环 (Generative Fine-tuning Loop)</strong>：</p>
<ul>
<li><strong>输入</strong>：文本 Prompt。</li>
<li><strong>过程</strong>：LLM 输出 SVG 参数（此时通常需要专门的 Head 输出数值，而不是 XML 文本），渲染成图，计算 CLIP Loss，反传梯度更新 LLM 权重。</li>
<li><strong>难点</strong>：LLM 输出通常是离散 Token。需要结合 Reparameterization Trick 或使用 Policy Gradient (RL) 方法。</li>
</ul>
</li>
<li>
<p><strong>感知监督环 (Perceptual Supervision Loop)</strong>：</p>
<ul>
<li><strong>核心思想</strong>：不要让模型去拟合像素（Pixel Loss），因为 SVG 是高度抽象的。</li>
<li><strong>做法</strong>：渲染图 $\rightarrow$ 降采样/多尺度 $\rightarrow$ 视觉编码器 (ViT) $\rightarrow$ 特征向量。</li>
<li><strong>Loss</strong>：计算特征向量之间的 Cosine Distance。这允许模型画出的猫虽然位置偏了一点，但“语义”上还是猫，Loss 不会爆炸。</li>
</ul>
</li>
</ol>
<h3 id="25-pixel-perceptual-semantic">2.5 视觉监督设计：Pixel, Perceptual, Semantic</h3>
<p>选择哪种 Loss 决定了模型会生成什么样的 SVG：</p>
<p>| Loss 类型 | 数学形式 | 优点 | 缺点 | 适用场景 |</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Loss 类型</th>
<th style="text-align: left;">数学形式</th>
<th style="text-align: left;">优点</th>
<th style="text-align: left;">缺点</th>
<th style="text-align: left;">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Pixel-wise</strong></td>
<td style="text-align: left;">MSE (L2), L1</td>
<td style="text-align: left;">计算极快，实现简单</td>
<td style="text-align: left;">对位移极敏感，导致生成模糊，无法容忍拓扑差异</td>
<td style="text-align: left;">简单的几何图形拟合</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Perceptual</strong></td>
<td style="text-align: left;">LPIPS, VGG Feature</td>
<td style="text-align: left;">模仿人眼视觉，关注纹理和结构</td>
<td style="text-align: left;">计算量大，需要加载额外的预训练网络</td>
<td style="text-align: left;">图标重建，风格迁移</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Semantic</strong></td>
<td style="text-align: left;">CLIP/DINO Similarity</td>
<td style="text-align: left;">关注高层语义（"是一只狗"）</td>
<td style="text-align: left;">忽略几何细节，可能画出甚至无法辨认但语义对齐的图</td>
<td style="text-align: left;">Text-to-SVG 生成</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Regularization</strong></td>
<td style="text-align: left;">Path Length, Curvature</td>
<td style="text-align: left;">约束几何复杂度</td>
<td style="text-align: left;">防止产生乱线，保持简洁</td>
<td style="text-align: left;">作为辅助 Loss 必选</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Rule of Thumb</strong>：通常采用 <strong>组合 Loss</strong>。例如：<code>L_total = λ1 * L_LPIPS + λ2 * L_CLIP + λ3 * L_Reg</code>。没有正则化项（L_Reg），可微渲染往往会生成充满自交和极度扭曲的线条，因为那是数学上降低 Loss 的捷径。</p>
</blockquote>
<hr />
<h2 id="3">3. 本章小结</h2>
<p>本章揭示了 SVG-MLLM 背后的“视觉引擎”。</p>
<ol>
<li>我们确立了 <strong><code>resvg</code></strong> 作为数据清洗和最终评测的绝对标准，确保数据的合法性。</li>
<li>我们引入了 <strong><code>PyTorch-SVGRender</code></strong> 作为训练时的可微代理，通过软光栅化技术（Soft Rasterization）解决了从像素到几何参数的梯度反传难题。</li>
<li>我们构建了训练闭环的理论框架：不仅要让模型学习生成符合语法的 XML（语言模型任务），还要通过渲染器提供的视觉反馈，学习生成符合视觉预期的图形（视觉生成任务）。</li>
</ol>
<p>掌握了渲染，你的模型就不再是“盲写”代码，而是开始“学画”了。</p>
<hr />
<h2 id="4">4. 练习题</h2>
<h3 id="_1">基础题 (熟悉材料)</h3>
<ol>
<li><strong>流程图绘制</strong>：请画出一个流程图，描述从“原始网络爬取的 SVG”到“用于训练的高质量图文对”的数据处理流水线。请明确标出在哪里使用 <code>resvg</code>，在哪里进行 XML 解析。</li>
<li><strong>渲染器差异</strong>：为什么在训练基于梯度的优化任务（如 Deep Image Prior for SVG）时，不能使用 <code>resvg</code>？请从数学导数的角度解释。</li>
<li><strong>Loss 直觉</strong>：给定一个目标图像（黑底白圆），模型生成了一个位置正确但只有一半大小的圆。<ul>
<li>计算 L1 Loss（像素差绝对值）是大还是小？</li>
<li>如果把生成的圆向目标圆心移动 1 个像素，L1 Loss 会变小吗？这说明了什么？</li>
</ul>
</li>
</ol>
<h3 id="_2">挑战题 (深度思考)</h3>
<ol start="4">
<li>
<p><strong>梯度消失问题</strong>：
    在可微渲染中，如果生成的图形（例如一个小正方形）和目标图形完全不重叠，且距离很远。此时计算像素级 Loss，梯度会是多少？为什么？这对于初始化策略有什么启示？</p>
<ul>
<li>
<p><em>提示：思考“软光栅化”的影响范围（Kernel Size/Radius）。如果距离超过了影响范围，导数是否还存在？</em>
5.  <strong>描边（Stroke）的歧义</strong>：
一个黑色的实心圆（Fill）和一个极粗的黑色圆环（Stroke），在视觉上可能看起来一模一样。</p>
</li>
<li>
<p>如果仅用像素 Loss 监督，模型能区分这两者吗？</p>
</li>
<li>
<p>这对生成的 SVG 的“可编辑性”有什么危害？如何通过正则化 Loss 来解决？
6.  <strong>多尺度渲染（Multi-scale Rendering）</strong>：
为了加速训练并避免局部极小值，研究者常在训练初期使用低分辨率渲染（如 64x64），后期使用高分辨率（如 224x224）。</p>
</li>
<li>
<p>请分析这种策略对“粗糙形状”和“精细细节”学习顺序的影响。</p>
</li>
<li>这与人类画画的步骤有何异同？</li>
</ul>
</li>
</ol>
<details>
<summary>点击查看答案解析</summary>
<ol>
<li><strong>流程图思路</strong>：Raw SVG -&gt; (XML Parser: 修复语法/去脚本) -&gt; (Canonicalizer: 归一化) -&gt; <strong>(resvg: 渲染)</strong> -&gt; (Filter: 剔除空白/全黑图) -&gt; (Resizer: 统一尺寸) -&gt; Dataset。</li>
<li><strong>渲染器差异</strong>：<code>resvg</code> 执行的是硬判断（Hard Decision），像素颜色 $I$ 关于坐标 $x$ 的函数 $I(x)$ 是阶跃的。在阶跃点不可导，非阶跃点导数为0。无法利用链式法则 $\partial L / \partial x = (\partial L / \partial I) \cdot (\partial I / \partial x)$ 进行更新。</li>
<li><strong>Loss 直觉</strong>：<ul>
<li>L1 Loss 会比较大（未重叠区域都是误差）。</li>
<li>如果完全不重叠，移动 1 像素，L1 Loss <strong>不变</strong>（因为像素变化是离散的，且如果不重叠，背景对背景，前景对前景，误差恒定）。这说明 L1 Loss 在无重叠时缺乏引导性（没有任何梯度告诉圆该往哪边跑）。</li>
</ul>
</li>
<li><strong>梯度消失</strong>：<ul>
<li>梯度为 0。因为软光栅化的平滑作用通常只在边缘附近的几个像素内有效（基于卷积核或距离阈值）。如果完全不重叠且距离超过这个阈值，像素变化对几何参数的偏导数为 0。</li>
<li><strong>启示</strong>：初始化非常重要。通常需要将图形初始化在画布中央并覆盖较大面积，或者使用“Coarse-to-Fine”策略，先优化大模糊块，再优化细节。</li>
</ul>
</li>
<li><strong>描边歧义</strong>：<ul>
<li>仅靠像素 Loss 无法区分。</li>
<li><strong>危害</strong>：用户拿到 SVG 想修改圆的大小时，如果是 Stroke 实现的，修改半径可能导致线条变细，这不符合预期。结构混乱。</li>
<li><strong>解决</strong>：引入 Parse Loss 或 MDL (Minimum Description Length) 思想，惩罚过粗的 Stroke，或者惩罚用 Stroke 模拟 Fill 的行为。</li>
</ul>
</li>
<li><strong>多尺度渲染</strong>：<ul>
<li>低分辨率下，高频细节丢失，Loss 景观更平滑，模型更容易捕捉整体位置和颜色（类似于模糊处理扩大了梯度的有效范围）。</li>
<li>高分辨率下，模型细化边缘。</li>
<li>这与人类先画草稿（定轮廓）再画细节（勾线）的过程高度一致。</li>
</ul>
</li>
</ol>
</details>
<hr />
<h2 id="5-gotchas">5. 常见陷阱与错误 (Gotchas)</h2>
<h3 id="51-nan-not-a-number">5.1 恐怖的 NaN (Not a Number)</h3>
<ul>
<li><strong>现象</strong>：训练了几步之后，Loss 突然变成 <code>NaN</code>，模型参数全毁。</li>
<li><strong>原因</strong>：这是可微矢量渲染中最常见的问题。<ol>
<li><strong>贝塞尔曲线退化</strong>：控制点重合，导致曲线长度为 0，在计算切线或法线时出现除以零。</li>
<li><strong>自交计算</strong>：某些复杂的自交路径在计算拓扑环绕数时数值不稳定。</li>
</ol>
</li>
<li><strong>调试技巧</strong>：<ul>
<li>在 Loss 计算前加 <code>torch.clamp</code>。</li>
<li>给控制点加微小的随机噪声（Jitter），防止完全重合。</li>
<li>检测到 NaN 时跳过该 Batch 更新，并打印出导致崩溃的 SVG 参数进行分析。</li>
</ul>
</li>
</ul>
<h3 id="52-gamma-trap">5.2 颜色空间的伽马陷阱 (Gamma Trap)</h3>
<ul>
<li><strong>现象</strong>：渲染出来的图和 GT 相比，总是显得“灰蒙蒙”或者边缘有黑边。</li>
<li><strong>原因</strong>：<ul>
<li>SVG 颜色定义（如 <code>#FF0000</code>）通常在 sRGB 空间（经过 Gamma 2.2 编码）。</li>
<li>物理光照混合（Alpha Compositing）应该在<strong>线性空间 (Linear Space)</strong> 进行。</li>
<li>CNN/ViT 通常期望输入经过 ImageNet 统计量的归一化，或者在 sRGB 空间。</li>
</ul>
</li>
<li><strong>Rule of Thumb</strong>：<strong>始终在线性空间做渲染和合成</strong>，在最后输出给 Loss 计算或保存图片前，再转回 sRGB。混淆这两者会导致严重的亮度偏差。</li>
</ul>
<h3 id="53">5.3 视口外的“幽灵梯度”</h3>
<ul>
<li><strong>现象</strong>：模型把图形画到了画布外面，怎么都拉不回来。</li>
<li><strong>原因</strong>：一旦控制点跑出了 Canvas 范围（例如坐标变成 -100），渲染出的像素全黑。此时像素对该控制点的梯度为 0（因为无论该控制点怎么微调，画面依然是黑的）。参数这就“死”在外面了。</li>
<li><strong>对策</strong>：<ul>
<li>对输出坐标加 <code>Sigmoid</code> 或 <code>Tanh</code> 激活函数，强制限制在 <code>[0, 1]</code> 或 <code>[-1, 1]</code> 范围内。</li>
<li>或者加一个正则项：<code>L_bound = ReLU(|x| - 1.0)</code>，只要出界就产生巨大的惩罚梯度把它拉回来。</li>
</ul>
</li>
</ul>
<h3 id="54-stroke-fill">5.4 只有 Stroke 没有 Fill 的尴尬</h3>
<ul>
<li><strong>现象</strong>：模型试图用无数条细线去填满一个色块，而不是直接用 <code>&lt;path fill="..." /&gt;</code>。</li>
<li><strong>原因</strong>：从梯度下降的角度看，移动一根线条去覆盖像素比改变拓扑结构（增加一个闭合路径）要容易得多。这是局部最优解。</li>
<li><strong>对策</strong>：在数据预处理阶段，分离 Fill 和 Stroke 的数据。或者在模型设计上强制区分“轮廓层”和“填充层”，不让模型偷懒。</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter6.html" class="nav-link prev">← 第 6 章：SVG 结构化表示：从文本到 Token / AST / 图</a><a href="chapter8.html" class="nav-link next">第 8 章：DeepSVG：学习式 SVG 表示与生成基线 →</a></nav>
        </main>
    </div>
</body>
</html>