<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第 8 章：DeepSVG：学习式 SVG 表示与生成基线</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">SVG-MLLM：基于 SVG 的多模理解生成一体化大模型（中文教程）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 1 章：从 SVG 到 SVG-MLLM：问题定义与路线图</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 2 章：SVG 核心语法：从 XML 到几何表达</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 3 章：SVG 与 Web 联动：DOM、CSS、JS 与 three.js 协同</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[第 4 章：Web SVG 数据工程：采集、清洗、规范化与对齐](chapter4.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[第 5 章：传统矢量化与图像追踪（Image Tracing）算法](chapter5.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 6 章：SVG 结构化表示：从文本到 Token / AST / 图</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 7 章：渲染引擎与训练闭环：resvg 与 PyTorch-SVGRender</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 8 章：DeepSVG：学习式 SVG 表示与生成基线</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 9 章：从 Stroke 到 Path：Sketch 系列思想与贝塞尔生成</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 11 章：SVG-MLLM 架构设计：理解与生成一体化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 12 章：训练流程：预训练、指令微调、偏好对齐与有效性保障</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="8-deepsvg-svg">第 8 章：DeepSVG：学习式 SVG 表示与生成基线</h1>
<h2 id="81">8.1 开篇段落</h2>
<p>在第 5 章中，我们探讨了如何通过传统算法（如 Potrace）将栅格图像追踪为矢量图；在第 6 章中，我们学习了如何将 SVG 解析为结构化数据。然而，传统算法缺乏语义理解能力——它们无法“凭空想象”一个图标，也无法理解“圆形”和“正方形”在潜在空间中的语义关系。</p>
<p>本章将深入探讨 <strong>DeepSVG (NeurIPS 2020)</strong>，这是深度学习领域处理 SVG 数据的里程碑式工作。DeepSVG 首次成功地将 SVG 建模为<strong>层次化序列（Hierarchical Sequence）</strong>，并利用 Transformer 和 VAE（变分自编码器）架构实现了高质量的矢量图标重建、生成和插值。</p>
<p>掌握 DeepSVG 不仅仅是学习一个特定的模型，更是为了掌握一套<strong>通用的矢量建模方法论</strong>：如何将连续的几何坐标离散化？如何处理长短不一的路径组合？如何平衡拓扑结构与几何精度？这些问题的解决方案将直接决定我们在后续章节构建的 SVG-MLLM 的底座质量。</p>
<hr />
<h2 id="82">8.2 文字论述</h2>
<h3 id="821">8.2.1 数据的“降维打击”：简化与标准化表示</h3>
<p>SVG 标准（SVG 1.1/2.0）极其复杂，包含数十种指令和极其灵活的参数。直接将原始 XML 喂给神经网络是不可行的。DeepSVG 确立了一套标准的数据预处理流水线，这套 <strong>Rule-of-Thumb</strong> 被后来的大多数工作（如 IconShop, StarVector）所沿用。</p>
<h4 id="1-primitive-unification">1. 图元统一化 (Primitive Unification)</h4>
<p>模型不需要知道什么是 <code>&lt;rect&gt;</code>、<code>&lt;circle&gt;</code> 或 <code>&lt;polygon&gt;</code>。在几何上，它们都可以被数学表达能力更强的 <strong>三次贝塞尔曲线 (Cubic Bézier Curves)</strong> 完美模拟或近似。</p>
<ul>
<li><strong>直线</strong>：控制点共线的贝塞尔曲线。</li>
<li><strong>圆/椭圆</strong>：通常用 4 段贝塞尔曲线拼接近似（误差极小）。</li>
<li><strong>转换优势</strong>：将指令集词表（Vocabulary）从几十个压缩到极简集合：<code>Move (M)</code>, <code>Line (L)</code>, <code>Cubic (C)</code>, <code>Close (Z)</code>。DeepSVG 进一步将 L 也视为特殊的 C，极致简化输出空间。</li>
</ul>
<h4 id="2">2. 坐标归一化与张量结构</h4>
<p>SVG 的画布大小各异。为了让模型学习“形状”而非“位置”，必须进行 Canonicalization（规范化）：</p>
<ul>
<li><strong>ViewBox 对齐</strong>：解析 <code>viewBox</code>，将图形平移缩放到单位正方形 $[0, 1]$ 或 $[0, 255]$ 范围内。</li>
<li><strong>路径排序</strong>：SVG 路径顺序在渲染时影响遮挡关系，但在语义上往往是无序集合。为了稳定训练，通常按路径的空间位置（如从上到下、从左到右）或长度对 <code>&lt;path&gt;</code> 进行重排。</li>
</ul>
<p><strong>DeepSVG 的张量表示 $V_{tensor}$</strong>：
一个 SVG 图标被表示为张量 $T$，维度为 $(N_P, N_C, N_F)$：</p>
<ul>
<li>$N_P$：最大路径数（Max Paths），例如 8。</li>
<li>$N_C$：每条路径的最大指令数（Max Commands），例如 50。</li>
<li>$N_F$：特征维度，通常包含：<ol>
<li><strong>Command Type</strong>：One-hot 编码（M, L, C, Z, EOS, SOS）。</li>
<li><strong>Coordinates</strong>：$(x, y)$ 坐标对。如果是贝塞尔曲线，则是 $(x_1, y_1, x_2, y_2, x, y)$。</li>
<li><strong>Visibility</strong>：二值标记，指示该路径/指令是否有效（用于 Padding 掩码）。</li>
</ol>
</li>
</ul>
<h3 id="822-transformer-hierarchical-transformer">8.2.2 核心架构：层次化 Transformer (Hierarchical Transformer)</h3>
<p>SVG 天然具有 <strong>“图 -&gt; 路径 -&gt; 指令”</strong> 的两级层级结构。普通的 Flat Transformer（将 SVG 视为一长串 token）会丢失这种结构信息，且注意力机制的 $O(L^2)$ 复杂度会随点数增加而爆炸。</p>
<p>DeepSVG 设计了<strong>非自回归编码（Encoder）</strong>与<strong>自回归解码（Decoder）</strong>的混合架构：</p>
<div class="codehilite"><pre><span></span><code><span class="k">[输入 SVG 张量]</span>
<span class="w">      </span><span class="na">|</span>
<span class="na">(1) Path Encoder (处理路径内部)</span>
<span class="w">      </span><span class="na">|  -&gt; 得到每个 Path 的 Embedding (P1, P2... Pn)</span>
<span class="w">      </span><span class="na">|</span>
<span class="na">(2) Global Encoder (处理路径之间)</span>
<span class="w">      </span><span class="na">|  -&gt; 聚合得到 Global Latent Vector (z) &lt;--- VAE 瓶颈在这里</span>
<span class="w">      </span><span class="na">|</span>
<span class="na">(3) Global Decoder (预测路径属性)</span>
<span class="w">      </span><span class="na">|  -&gt; 预测路径数量、起始点、样式</span>
<span class="w">      </span><span class="na">|</span>
<span class="na">(4) Path Decoder (生成具体指令)</span>
<span class="w">      </span><span class="na">|  -&gt; 针对每条路径，自回归生成：Cmd -&gt; Coord -&gt; Cmd -&gt; Coord...</span>
<span class="w">      </span><span class="na">|</span>
<span class="k">[输出 SVG 张量]</span>
</code></pre></div>

<ul>
<li><strong>Intra-path attention</strong>：只关注同一条路径内的点，捕捉局部形状（如圆角的曲率）。</li>
<li><strong>Inter-path attention</strong>：关注路径之间的空间关系（如眼睛要在脸的内部）。</li>
</ul>
<h3 id="823-latent-space-vae">8.2.3 潜在空间 (Latent Space) 与 VAE 魔法</h3>
<p>DeepSVG 不仅仅是一个 AutoEncoder，它是一个 <strong>VAE</strong>。引入 KL 散度损失项迫使潜在向量 $z$ 服从正态分布。这为 SVG 带来了<strong>可计算性</strong>：</p>
<ol>
<li>
<p><strong>平滑插值 (Morphing)</strong>：
    给定两个图标 $A$ 和 $B$，通过 $z_{mid} = \alpha z_A + (1-\alpha) z_B$，解码 $z_{mid}$ 可以得到一个在几何上介于两者之间的“杂交”图标。</p>
<ul>
<li><em>区别于像素插值</em>：像素插值是叠加淡入淡出；DeepSVG 插值是形状的动态形变（圆形逐渐变成方形）。
2.  <strong>语义运算</strong>：
$z_{\text{伤心脸}} \approx z_{\text{笑脸}} - z_{\text{向上嘴角}} + z_{\text{向下嘴角}}$（理想情况下）。</li>
</ul>
</li>
</ol>
<h3 id="824-loss-recipe-for-training">8.2.4 训练目标与 Loss 设计 (Recipe for Training)</h3>
<p>训练 DeepSVG 需要多任务损失函数的精细平衡：</p>
<p>$$ \mathcal{L} = \mathcal{L}_{\text{recon}} + \beta \mathcal{L}_{\text{KL}} $$</p>
<p>其中重建损失 $\mathcal{L}_{\text{recon}}$ 细分为：</p>
<ol>
<li><strong>命令分类损失 (Classification Loss)</strong>：交叉熵损失，判断当前是画直线、曲线还是闭合。<ul>
<li><em>Gotcha</em>：类别不平衡。Move (M) 指令很少，Line/Curve 很多，需要加权。</li>
</ul>
</li>
<li><strong>坐标回归损失 (Coordinate Regression Loss)</strong>：MSE 或 L1 Loss，预测控制点位置。<ul>
<li><em>Rule-of-Thumb</em>：只对 Ground Truth 中存在的坐标计算 Loss。如果 GT 是“直线”，预测出的“控制点”坐标不应产生梯度（因为直线没有控制点）。</li>
</ul>
</li>
<li><strong>可见性损失 (Visibility Loss)</strong>：二分类损失，判断生成的路径是否应该结束。</li>
</ol>
<h3 id="825">8.2.5 推理与生成策略</h3>
<p>在训练好模型后，生成过程（Inference）有多种玩法：</p>
<ul>
<li><strong>Greedy Search</strong>：每一步取概率最大的指令和坐标。生成稳定，但可能陷入局部最优。</li>
<li><strong>Sampling (Temperature)</strong>：按概率采样。增加多样性，但容易产生自交或畸形线条。</li>
<li><strong>Beam Search</strong>：保留前 K 个最优序列。对于 SVG 这种对拓扑结构敏感的数据，Beam Search 能显著减少“画了一半突然闭合”的错误。</li>
</ul>
<hr />
<h2 id="83">8.3 本章小结</h2>
<ul>
<li><strong>数据决定上限</strong>：DeepSVG 的成功很大程度上归功于将 SVG 简化为 <strong>Cubic Bézier 序列</strong> 并进行严格的归一化。</li>
<li><strong>结构匹配数据</strong>：层次化 Transformer（Path-level + Command-level）完美契合了 SVG 的 DOM 结构，比纯文本模型更高效。</li>
<li><strong>连续流形</strong>：通过 VAE，我们将离散的 SVG 代码映射到了连续的流形空间，使得矢量图形的运算和演变得以实现。</li>
<li><strong>局限性</strong>：DeepSVG 对于<strong>拓扑极为复杂</strong>（如包含孔洞、复杂的奇偶填充规则）的图形处理能力有限，且对<strong>长序列</strong>（超过 1000 个指令）会出现遗忘，这正是后续 StarVector 等工作试图解决的问题。</li>
</ul>
<hr />
<h2 id="84">8.4 练习题</h2>
<h3 id="_1">基础题（熟悉材料）</h3>
<ol>
<li><strong>预处理逻辑</strong>：给定一个 <code>&lt;rect x="10" y="10" width="20" height="20"/&gt;</code>，如果统一转换为 Cubic Bézier 格式，它将由几条指令组成？请写出大致的命令序列（M, C...）。</li>
<li><strong>张量维度计算</strong>：假设 $N_P=4, N_C=10$，每个指令包含 $(type, x, y)$，其中 type 有 6 种，坐标不量化。请问描述单张图片的张量最小需要多少个浮点数？</li>
<li><strong>VAE 作用</strong>：如果在训练 DeepSVG 时将 $\beta$（KL 散度的权重）设为 0，模型退化为普通 AutoEncoder。此时尝试对两个图标进行插值，预期会发生什么现象？</li>
<li><strong>架构细节</strong>：在 DeepSVG 的 Decoder 中，是先预测所有路径的起始点，还是预测完路径 1 的所有指令后再预测路径 2？（提示：回顾层次化结构）。</li>
</ol>
<h3 id="_2">挑战题（深入思考）</h3>
<ol start="5">
<li><strong>填充规则的歧义</strong>：SVG 的填充有 <code>nonzero</code> 和 <code>evenodd</code> 两种规则。DeepSVG 的标准实现主要关注轮廓（Stroke）。如果一个圆环是由两个同心圆路径组成的（大圆顺时针，小圆逆时针），DeepSVG 如何保证生成的一大一小两个圆能正确组成一个空心的圆环，而不是两个实心圆？</li>
<li><strong>序列顺序不变性 (Permutation Invariance)</strong>：SVG 文件中 <code>&lt;path&gt;</code> 的顺序打乱通常不影响视觉（除非重叠），但对 RNN/Transformer 来说是完全不同的序列。DeepSVG 采用了简单的排序策略。请设计一种更先进的 Loss 或架构，使模型对路径输入的顺序不敏感（Set Prediction）。</li>
<li><strong>坐标的量化与回归</strong>：DeepSVG 原文中对坐标直接回归浮点数，但后续有很多工作（如 Image generation 中的 VQ-VAE）主张将坐标离散化为 Token（例如 0-255 的整数）。请分析“回归浮点数”与“预测坐标Token”在 SVG 生成任务中各自的优劣。</li>
<li><strong>从 SVG-MLLM 的角度</strong>：如果我们要把 DeepSVG 作为一个 Visual Tokenizer 接入 LLM，它的 Latent Vector $z$ 适合直接作为 LLM 的输入 Token 吗？如果不适合，需要做什么转换？</li>
</ol>
<details>
<summary>点击查看练习题提示与答案方向</summary>
<ol>
<li><strong>答案</strong>：至少 5 个指令：<code>M</code> (移动到角), <code>L</code>/<code>C</code> (边1), <code>L</code>/<code>C</code> (边2), <code>L</code>/<code>C</code> (边3), <code>L</code>/<code>C</code> (边4), <code>Z</code> (闭合)。DeepSVG 可能会把 L 也变成 C。</li>
<li><strong>答案</strong>：$4 \times 10 \times (6 + 2) = 320$。实际实现中会有 Padding mask 和 Visibility 位。</li>
<li><strong>答案</strong>：插值会变得不平滑。中间状态可能不是一个合法的图形，或者在两张图之间生硬跳变，而不是渐变变形。</li>
<li><strong>答案</strong>：通常是分层的。Global Decoder 先确定路径的宏观属性（如起始点、Latent），然后 Path Decoder 逐个或并行地展开每条路径的具体指令。</li>
<li><strong>提示</strong>：这是一个痛点。模型需要隐式学习到“内嵌的路径通常是孔洞”这一规律。更强的做法是显式预测路径的方向（顺/逆时针）作为特征。</li>
<li><strong>提示</strong>：参考 DETR (Detection Transformer) 的匈牙利匹配损失 (Hungarian Matching Loss)。在计算 Loss 之前，先找到预测路径集合与真实路径集合之间的最佳二分图匹配。</li>
<li><strong>提示</strong>：回归浮点数精度高，但容易产生模糊的“平均值”结果；离散 Token 容易捕捉多峰分布（即边缘锐利），但不仅这就增加了词表大小，还需要处理量化误差。</li>
<li><strong>提示</strong>：不适合。$z$ 是连续向量，LLM 只能处理离散 Token。需要经过 Quantization (如 VQ-VAE 的 Codebook) 将 $z$ 映射为离散的 ID 序列，或者通过一个 Linear Projector 将 $z$ 投影到 LLM 的 Embedding 空间（类似 LLaVA）。</li>
</ol>
</details>
<hr />
<h2 id="85-gotchas">8.5 常见陷阱与错误 (Gotchas)</h2>
<p>在复现或使用 DeepSVG 时，以下陷阱会让你的 Loss 居高不下或生成结果一团糟：</p>
<ol>
<li>
<p><strong>幽灵路径 (The Phantom Paths)</strong></p>
<ul>
<li><strong>现象</strong>：模型生成的 SVG 代码看起来正常，但浏览器渲染出来一片空白或缺失部分。</li>
<li><strong>原因</strong>：训练数据中包含大量 <code>opacity="0"</code> 或 <code>display="none"</code> 的垃圾路径，或者路径的 <code>fill</code> 和 <code>stroke</code> 属性未被正确预测（默认为无色）。</li>
<li><strong>对策</strong>：在数据清洗阶段，<strong>必须渲染</strong>一遍以剔除不可见路径。在生成阶段，强制设置默认的 <code>stroke="black"</code> 和 <code>fill="none"</code> 用于调试。</li>
</ul>
</li>
<li>
<p><strong>贝塞尔曲线“飞线” (Exploding Control Points)</strong></p>
<ul>
<li><strong>现象</strong>：图形大体正常，但偶尔有一两条线飞出屏幕几千像素远。</li>
<li><strong>原因</strong>：回归 Loss 对异常值不够敏感，或者模型未能学好控制点与端点的相对关系。</li>
<li><strong>对策</strong>：使用 <code>Smooth L1 Loss</code> 代替 <code>MSE</code>；或者将绝对坐标预测改为预测<strong>相对偏移量 (Relative Offsets)</strong>，限制控制点的活动范围。</li>
</ul>
</li>
<li>
<p><strong>Start/End Token 的混淆</strong></p>
<ul>
<li><strong>现象</strong>：生成序列无法停止，或者路径之间粘连。</li>
<li><strong>原因</strong>：混淆了 <code>Global EOS</code>（整个图标结束）和 <code>Path EOS</code>（当前路径结束）。</li>
<li><strong>对策</strong>：在构建词表时，严格区分层级 Token。检查 Mask 矩阵是否正确屏蔽了 Padding 区域。</li>
</ul>
</li>
<li>
<p><strong>过拟合于简单的几何变换</strong></p>
<ul>
<li><strong>现象</strong>：模型只会平移或缩放，无法改变形状。</li>
<li><strong>原因</strong>：数据集通过简单的 Affine Transformation 扩增太多，导致模型“偷懒”。</li>
<li><strong>对策</strong>：增加非线性扩增（如对控制点加高斯噪声），强迫模型学习形状的鲁棒表示。</li>
</ul>
</li>
<li>
<p><strong>ViewBox 的陷阱</strong></p>
<ul>
<li><strong>错误</strong>：直接读取 <code>d</code> 属性中的坐标进行训练，忽略了父级 <code>&lt;g transform="..."&gt;</code> 或根节点的 <code>viewBox</code>。</li>
<li><strong>后果</strong>：不同 SVG 的坐标量级相差巨大（有的 0-100，有的 0-10000），导致梯度爆炸或无法收敛。</li>
<li><strong>对策</strong>：必须实现一个完整的 <strong>Flatten Transform</strong> 算法，将所有变换矩阵应用到叶子节点的路径坐标上，统一转换到世界坐标系后再归一化。</li>
</ul>
</li>
</ol>
            </article>
            
            <nav class="page-nav"><a href="chapter7.html" class="nav-link prev">← 第 7 章：渲染引擎与训练闭环：resvg 与 PyTorch-SVGRender</a><a href="chapter9.html" class="nav-link next">第 9 章：从 Stroke 到 Path：Sketch 系列思想与贝塞尔生成 →</a></nav>
        </main>
    </div>
</body>
</html>