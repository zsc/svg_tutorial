<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第 13 章：评测体系：像素、结构、语义与可编辑性</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">SVG-MLLM：基于 SVG 的多模理解生成一体化大模型（中文教程）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 1 章：从 SVG 到 SVG-MLLM：问题定义与路线图</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 2 章：SVG 核心语法：从 XML 到几何表达</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 3 章：SVG 与 Web 联动：DOM、CSS、JS 与 three.js 协同</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[第 4 章：Web SVG 数据工程：采集、清洗、规范化与对齐](chapter4.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">[第 5 章：传统矢量化与图像追踪（Image Tracing）算法](chapter5.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 6 章：SVG 结构化表示：从文本到 Token / AST / 图</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 7 章：渲染引擎与训练闭环：resvg 与 PyTorch-SVGRender</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 8 章：DeepSVG：学习式 SVG 表示与生成基线</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 9 章：从 Stroke 到 Path：Sketch 系列思想与贝塞尔生成</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 10 章：现代 SVG 工作谱系综述：StarVector、OmniSVG、InternSVG 等</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 11 章：SVG-MLLM 架构设计：理解与生成一体化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 12 章：训练流程：预训练、指令微调、偏好对齐与有效性保障</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 13 章：评测体系：像素、结构、语义与可编辑性</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 14 章：SVG Animation：时间维度、交互与可控运动生成</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 15 章：应用专题 I：字体、字形生成与排版 (SVG × Typography)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 16 章：应用专题 II：BEV 矢量地图与系统落地（SVG × Map/Driving）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="13">第 13 章：评测体系：像素、结构、语义与可编辑性</h1>
<h2 id="1">1. 开篇与学习目标</h2>
<p>在多模态大模型（MLLM）的语境下，评价一个 SVG 生成模型的性能远比评价 Stable Diffusion 这种纯像素生成模型要复杂。因为 SVG 具有<strong>双重属性</strong>：</p>
<ol>
<li><strong>视觉属性</strong>：它渲染后是一张图像，必须符合人类的视觉审美和语义要求。</li>
<li><strong>代码属性</strong>：它本质上是一段 XML 代码，必须符合语法规范，且具备拓扑结构上的合理性。</li>
</ol>
<p>一个“视觉上完美”但“代码由一万个乱序微小线段组成”的 SVG，在工程上是不可用的垃圾数据（不可编辑、渲染卡顿、无限放大失真）。反之，代码极其精简但画得不像的 SVG 也是失败的。</p>
<p>本章将建立一个<strong>全方位、分层级</strong>的评测体系，从底层的语法解析率，到中间层的几何拓扑质量，再到顶层的语义对齐度，为你提供一套可复用、可量化的“体检报告”生成方案。</p>
<p><strong>本章学习目标：</strong></p>
<ul>
<li><strong>掌握渲染层评测</strong>：深入理解 LPIPS、FID 在矢量图领域的适用性与局限。</li>
<li><strong>构建结构层评测</strong>：学会量化“可编辑性”，通过几何特征识别“伪矢量”（由像素描摹导致的过度拟合）。</li>
<li><strong>实施语义层评测</strong>：利用 CLIP 和 VLM（如 GPT-4V）作为裁判进行自动化打分。</li>
<li><strong>数据卫生管理</strong>：掌握基于渲染指纹（Rendered Fingerprint）的严格去重策略，防止测试集泄漏。</li>
<li><strong>搭建 Eval Harness</strong>：设计一套自动化的评测流水线。</li>
</ul>
<hr />
<h2 id="2">2. 核心论述</h2>
<h3 id="21-canonicalization">2.1 评测流水线设计：标准化（Canonicalization）</h3>
<p>在计算任何指标之前，必须对模型生成的 SVG 和 Ground Truth（真实数据）进行“对齐”。直接比较两个 SVG 的文本字符串（BLEU/Rouge）是毫无意义的，因为 <code>path d="M 0 0 L 10 10"</code> 和 <code>path d="M 0 0 l 10 10"</code>（相对坐标）视觉一样但文本不同。</p>
<p><strong>标准评测流水线 (Evaluation Pipeline)</strong>：</p>
<ol>
<li><strong>语法修复 (Syntax Repair)</strong>：使用 <code>lxml</code> 或 <code>BeautifulSoup</code> 尝试解析输出。如果模型输出缺少闭合标签 <code>&lt;/svg&gt;</code>，尝试自动补全。</li>
<li><strong>视口归一化 (Viewport Normalization)</strong>：<ul>
<li>读取 <code>viewBox</code>。如果缺失，计算 bounding box。</li>
<li>将所有坐标通过矩阵变换映射到 $[0, 1] \times [0, 1]$ 或固定尺寸（如 $256 \times 256$）的统一坐标系中。</li>
<li>这一步是为了消除位移（Translation）和缩放（Scale）带来的无关误差。</li>
</ul>
</li>
<li><strong>样式内联 (Style Inlining)</strong>：将 CSS class 转换为内联样式，确保渲染引擎不会因为缺少 CSS 解析器而渲染成黑色方块。</li>
<li><strong>栅格化 (Rasterization)</strong>：使用 <code>resvg</code> 或 <code>Cairo</code> 将 SVG 渲染为 PNG。通常建议渲染两套分辨率：<ul>
<li><strong>低分（64x64）</strong>：用于计算拓扑概览和颜色分布。</li>
<li><strong>高分（512x512）</strong>：用于计算细节 LPIPS 和边缘质量。</li>
</ul>
</li>
</ol>
<h3 id="22-rendering-metrics">2.2 维度一：视觉与像素层评测 (Rendering Metrics)</h3>
<p>这是最直观的评测，回答“<strong>画得像不像</strong>”的问题。</p>
<h4 id="221-pixel-wise-metrics">2.2.1 像素级距离 (Pixel-wise Metrics)</h4>
<ul>
<li><strong>MSE (Mean Squared Error) / L1 / L2</strong>：计算像素差值的平方和。<ul>
<li><em>局限性</em>：对<strong>位移</strong>极其敏感。如果生成图只是向右平移了 1 个像素，MSE 会爆炸，但人类觉得这是一样的。仅适用于严格对齐的 Icon 重建任务。</li>
</ul>
</li>
<li><strong>IoU (Intersection over Union)</strong>：<ul>
<li>适用于单色/二值化图形。</li>
<li>$IoU = \frac{Area(Gen \cap Ref)}{Area(Gen \cup Ref)}$</li>
<li><em>注意</em>：对于细线条图形，IoU 通常很低，建议先对线条进行膨胀（Dilation）操作再计算 IoU，这被称为 <strong>Relaxed IoU</strong>。</li>
</ul>
</li>
</ul>
<h4 id="222-perceptual-metrics">2.2.2 感知级距离 (Perceptual Metrics)</h4>
<ul>
<li><strong>LPIPS (Learned Perceptual Image Patch Similarity)</strong>：<strong>（黄金标准）</strong><ul>
<li>利用预训练的 VGG/AlexNet 提取深层特征计算距离。</li>
<li>它能容忍轻微的局部变形和位移，更符合人类直觉。SVG 生成任务中，LPIPS &lt; 0.1 通常意味着非常好的重建。</li>
</ul>
</li>
<li><strong>FID (Fréchet Inception Distance)</strong>：<ul>
<li>用于评估<strong>数据集整体分布</strong>的质量，而非单张图。</li>
<li>如果你做的是“无条件生成”或“类别条件生成”，需要计算生成集与真实集的 FID。FID 越低，生成的图像真实度和多样性越好。</li>
</ul>
</li>
</ul>
<h3 id="23-structural-metrics">2.3 维度二：结构与代码层评测 (Structural Metrics)</h3>
<p>这是区分“SVG 模型”和“像素模型”的关键。我们追求的是<strong>奥卡姆剃刀原则</strong>：用最少的指令描述最复杂的图形。</p>
<h4 id="231-complexity-sparsity">2.3.1 复杂度指标 (Complexity &amp; Sparsity)</h4>
<ul>
<li><strong>路径数量 (Path Count, $N_{path}$)</strong>：越少越好。</li>
<li><strong>指令数量 (Command Count, $N_{cmd}$)</strong>：总的绘图指令（M, L, C, Z 等）数量。</li>
<li><strong>控制点密度 (Control Point Density)</strong>：<ul>
<li>计算公式：$\rho = \frac{N_{points}}{Length_{path}}$</li>
<li><strong>判断标准</strong>：如果 $\rho$ 极高（例如每 2 个像素就有一个控制点），说明模型在进行“过拟合”或简单的“像素描摹（Tracing）”，这是<strong>低质量</strong>的矢量。高质量矢量应该用长贝塞尔曲线跨越长距离。</li>
</ul>
</li>
</ul>
<h4 id="232-primitive-usage">2.3.2 图元使用率 (Primitive Usage)</h4>
<ul>
<li><strong>Circle/Rect Ratio</strong>：<ul>
<li>检测模型是否学会了使用 <code>&lt;circle&gt;</code>, <code>&lt;rect&gt;</code>, <code>&lt;ellipse&gt;</code> 等高级图元，而不是全部用 <code>&lt;path&gt;</code> 拟合。</li>
<li><em>指标</em>：$R_{prim} = \frac{N_{shapes}}{N_{shapes} + N_{paths}}$。该值越高，说明模型对几何语义理解越深。</li>
</ul>
</li>
</ul>
<h4 id="233-code-validity">2.3.3 语法合法性 (Code Validity)</h4>
<ul>
<li><strong>Parse Rate</strong>：$\frac{Parsed}{Total}$。能否过 XML parser。</li>
<li><strong>Render Rate</strong>：$\frac{Rendered}{Total}$。解析后能否不报错地渲染（排除死循环、内存溢出、非法属性值）。</li>
<li><strong>Winding Rule Consistency</strong>：检测是否错误使用了 <code>fill-rule="evenodd"</code> 导致图形出现意外的空洞。</li>
</ul>
<h3 id="24-editability-topology">2.4 维度三：可编辑性与拓扑评测 (Editability &amp; Topology)</h3>
<p>可编辑性衡量的是 SVG 是否<strong>对人类设计师友好</strong>。</p>
<h4 id="241-closure">2.4.1 闭合性 (Closure)</h4>
<ul>
<li>对于填充（Fill）的区域，路径必须闭合。</li>
<li><em>检测</em>：检查 path 的最后指令是否为 <code>Z</code> 或 <code>z</code>。如果不是，计算起点 ($P_{start}$) 和终点 ($P_{end}$) 的欧氏距离。距离应小于 $\epsilon$。</li>
</ul>
<h4 id="242-hierarchy-grouping">2.4.2 层级结构 (Hierarchy &amp; Grouping)</h4>
<ul>
<li><strong>Group Utilization</strong>：模型是否使用了 <code>&lt;g&gt;</code> 标签？</li>
<li><strong>Semantic Grouping</strong>（高阶评测）：如果是生成“人脸”，理想情况下，“左眼”的所有路径应该在一个 <code>&lt;g id="left_eye"&gt;</code> 中。可以通过计算 Group 内元素的空间聚集度（Spatial Clustering）来评估。</li>
</ul>
<h4 id="243-redundancy-overdraw">2.4.3 冗余度 (Redundancy / Overdraw)</h4>
<ul>
<li><strong>看不见的路径</strong>：检测被上层不透明形状完全遮挡的下层路径。</li>
<li><strong>零长度路径</strong>：检测并惩罚 <code>d="M 10 10 L 10 10"</code> 这种无效指令。</li>
</ul>
<h3 id="25-semantic-alignment">2.5 维度四：语义一致性 (Semantic Alignment)</h3>
<p>当没有参考图（Reference-free），只有文本提示词（Prompt）时，如何判断生成得对不对？</p>
<h4 id="251-clip-based-metrics">2.5.1 CLIP-based Metrics</h4>
<ul>
<li><strong>CLIP Score</strong>：计算 <code>Sim(Image_Encoder(Gen_SVG), Text_Encoder(Prompt))</code>。</li>
<li><strong>CLIP-R-Precision</strong>：给定生成图和一组干扰文本，看 CLIP 能否检索到正确的 Prompt。</li>
<li><em>陷阱</em>：CLIP 对几何形状（“五角星” vs “六角星”）和数量（“三个苹果”）并不敏感。它更擅长物体类别和艺术风格。</li>
</ul>
<h4 id="252-llmvlm-as-a-judge-gpt-4v-llava">2.5.2 LLM/VLM-as-a-Judge (GPT-4V / LLaVA)</h4>
<p>这是目前最先进的评测方法。构建一个自动化裁判系统。</p>
<ul>
<li><strong>VQA 准确率</strong>：<ul>
<li>Prompt: "Draw a red triangle."</li>
<li>Eval Prompt (to VLM): "Look at this image. What shape is it? What color is it?"</li>
<li>计算 VLM 回答的准确率。</li>
</ul>
</li>
<li><strong>综合打分</strong>：<ul>
<li>Eval Prompt (to VLM): "Rate this SVG icon on a scale of 1-5 based on: 1. Visual clarity, 2. Relevance to prompt '{prompt}', 3. Aesthetic appeal."</li>
</ul>
</li>
</ul>
<h3 id="26-data-hygiene">2.6 数据集去重与防泄漏 (Data Hygiene)</h3>
<p>由于 SVG 源码的易变性，基于文本的去重（如 MinHash）是不够的。</p>
<p><strong>推荐的去重策略</strong>：</p>
<ol>
<li><strong>Rendered Hash</strong>：将所有训练集和测试集数据渲染为 64x64 灰度图。</li>
<li><strong>pHash (Perceptual Hash)</strong>：计算图像指纹。</li>
<li><strong>距离阈值</strong>：如果 Hamming Distance &lt; $T$（例如 5），则视为重复数据，从训练集中剔除。</li>
<li><strong>理由</strong>：这能防止模型仅仅是“记住了”训练集里的某个 SVG 代码，而不是学会了生成。</li>
</ol>
<hr />
<h2 id="3">3. 本章小结</h2>
<ul>
<li><strong>多维视角</strong>：SVG 评测 = <strong>LPIPS</strong> (看着像) + <strong>Complexity</strong> (代码简) + <strong>CLIP/VQA</strong> (语义对)。</li>
<li><strong>代码质量是隐形杀手</strong>：不要只看缩略图。必须检查控制点密度和路径数量，防止模型学会“伪矢量化”。</li>
<li><strong>渲染一致性</strong>：所有评测必须基于规范化的 ViewBox 和统一的渲染后端。</li>
<li><strong>大模型裁判</strong>：在缺乏 Ground Truth 的生成任务中，使用 VLM 进行 VQA 测试是目前最鲁棒的语义评测手段。</li>
<li><strong>严谨去重</strong>：基于渲染指纹的去重是保证 MLLM 泛化能力评估有效的底线。</li>
</ul>
<hr />
<h2 id="4">4. 练习题</h2>
<h3 id="_1">基础题</h3>
<ol>
<li><strong>[IoU 变体]</strong> 为什么对于细线条的 SVG 图标（Stroke-based icons），直接计算 IoU 分数通常极低且不具备参考价值？请提出一种改进方案。（Hint: 考虑线条宽度和对齐误差）。</li>
<li><strong>[复杂度计算]</strong> 编写一个伪代码函数 <code>calculate_complexity(svg_string)</code>，输入 SVG 字符串，返回其路径数、指令数和平均每条路径的控制点数。</li>
<li><strong>[LPIPS vs MSE]</strong> 给定一个正圆。情况 A：圆心向右偏移 2 像素。情况 B：圆变成了正方形，但位置完全重合。请预判 MSE 和 LPIPS 在这两种情况下的相对表现（谁对 A 惩罚大？谁对 B 惩罚大？）。</li>
<li><strong>[视口归一化]</strong> 一个 SVG 的 <code>viewBox="0 0 100 50"</code>，其中有一个点 <code>(50, 25)</code>。如果我们将其归一化到 <code>[0, 1] x [0, 1]</code> 的空间，这个点的新坐标是什么？注意保持纵横比（Aspect Ratio）的处理策略。</li>
</ol>
<h3 id="_2">挑战题</h3>
<ol start="5">
<li><strong>[自动化裁判 Prompt 设计]</strong> 你正在评测一个“Text-to-SVG”模型。请设计一段 System Prompt，发给 GPT-4V，让它不仅评估生成图的<strong>内容正确性</strong>，还要评估<strong>矢量图特有的美学</strong>（如线条流畅度、极简风格）。</li>
<li><strong>[可编辑性检测算法]</strong> 假设模型生成了一条由 100 个 <code>L</code> (Line) 指令组成的曲线，但这 100 个点其实都落在一条直线上。请设计一个算法来检测这种“冗余分段”，并计算“冗余率”。</li>
<li><strong>[对抗性攻击评测]</strong> 构造一个 SVG 案例（手动编写），使得它的 CLIP Score 极高（&gt;32），但 Parse Rate 为 0 或者人类看起来完全是乱码。（Hint: CLIP 攻击通常涉及在图像中隐藏文字或纹理）。</li>
<li><strong>[闭环评测系统设计]</strong> 设计一个 Python 类结构 <code>SVGEvaluator</code>，包含 <code>evaluate_visual()</code>, <code>evaluate_code()</code>, <code>evaluate_semantic()</code> 三个方法。要求支持 batch 处理和 GPU 加速（针对 LPIPS/CLIP）。</li>
</ol>
<hr />
<h3 id="_3">练习题提示与答案</h3>
<details>
<summary><strong>点击查看提示与答案思路</strong></summary>
<ol>
<li>
<p><strong>IoU 变体</strong></p>
<ul>
<li><strong>Hint</strong>: Thin lines have minimal area intersection if shifted slightly.</li>
<li><strong>Answer</strong>: 细线条的交集对位移极度敏感。改进方案：<strong>Relaxed IoU</strong>。在计算 IoU 前，对生成图和参考图都进行形态学<strong>膨胀（Dilation）</strong>操作（例如膨胀 3-5 个像素），增加容错率，关注拓扑重叠而非像素重叠。</li>
</ul>
</li>
<li>
<p><strong>复杂度计算</strong></p>
<ul>
<li><strong>Hint</strong>: Use a regex or SVG parser library like <code>svgpathtools</code>.</li>
<li><strong>Answer</strong>: 解析 <code>d</code> 属性，Count 'M','L','C'...。Count Points based on command type (C=3 points, L=1 point). Avg = Total Points / Total Paths.</li>
</ul>
</li>
<li>
<p><strong>LPIPS vs MSE</strong></p>
<ul>
<li><strong>Hint</strong>: MSE hates misalignment. LPIPS looks at features (edges/shapes).</li>
<li><strong>Answer</strong>: MSE 对情况 A（平移）惩罚极大，对情况 B（形状变异但重叠面积大）可能惩罚较小。LPIPS 对情况 A 惩罚较小（特征图平移不变性），对情况 B（形状特征彻底改变）惩罚大。LPIPS 更符合人类判断：平移的圆还是圆，但正方形不是圆。</li>
</ul>
</li>
<li>
<p><strong>视口归一化</strong></p>
<ul>
<li><strong>Hint</strong>: Map (x, y) to (x/w, y/h). Handling Aspect Ratio usually means centering or scaling by max dimension.</li>
<li><strong>Answer</strong>: 如果忽略纵横比拉伸：<code>(0.5, 0.5)</code>。如果保持纵横比（Fit in 1x1）：最大边长是 100，缩放因子 $s = 1/100$。新坐标 <code>(50*0.01, 25*0.01) = (0.5, 0.25)</code>，并在 Y 轴方向可能需要居中偏移。</li>
</ul>
</li>
<li>
<p><strong>自动化裁判 Prompt</strong></p>
<ul>
<li><strong>Hint</strong>: Define criteria explicitly.</li>
<li><strong>Answer</strong>: "Role: You are a Senior Vector Graphic Designer. Task: Evaluate the attached image generated from the prompt '{prompt}'. Criteria: 1. Semantic Accuracy (Is the object correct?). 2. Vector Aesthetics (Are lines smooth? Is the composition balanced? Is it clean or messy?). Output strictly JSON: {score_semantic: 1-10, score_aesthetic: 1-10, reasoning: '...'}"</li>
</ul>
</li>
<li>
<p><strong>可编辑性检测算法</strong></p>
<ul>
<li><strong>Hint</strong>: Collinearity check based on slopes or cross product.</li>
<li><strong>Answer</strong>: 遍历所有相邻线段 $P_{i-1}, P_i, P_{i+1}$。计算向量 $\vec{v_1} = P_i - P_{i-1}$ 和 $\vec{v_2} = P_{i+1} - P_i$。如果两个向量的夹角接近 0（或叉积接近 0），则点 $P_i$ 是冗余的。统计这类点的比例。</li>
</ul>
</li>
<li>
<p><strong>对抗性攻击评测</strong></p>
<ul>
<li><strong>Hint</strong>: CLIP reads text inside images well.</li>
<li><strong>Answer</strong>: 可以在 SVG 中插入大量微小的文字（如写满 "apple"），或者用杂乱的线条拼凑出 "apple" 的字样。CLIP 会识别文字语义给高分，但这在图形上不是一个苹果。如果 SVG 代码里全是 <code>&lt;text&gt;</code> 标签而没有图形，Parse Rate 虽高但作为图形生成任务是失败的。</li>
</ul>
</li>
<li>
<p><strong>闭环评测系统设计</strong></p>
<ul>
<li><strong>Hint</strong>: Structure involves dataloader, renderer, model interfaces.</li>
<li><strong>Answer</strong>:</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SVGEvaluator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lpips_model</span> <span class="o">=</span> <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip_model</span> <span class="o">=</span> <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renderer</span> <span class="o">=</span> <span class="n">ResvgRenderer</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_visual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">svg_code</span><span class="p">,</span> <span class="n">gt_image</span><span class="p">):</span>
        <span class="c1"># render -&gt; tensor -&gt; lpips</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">svg_code</span><span class="p">):</span>
        <span class="c1"># parse -&gt; check paths/commands -&gt; complexity score</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_semantic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">svg_code</span><span class="p">,</span> <span class="n">prompt</span><span class="p">):</span>
        <span class="c1"># render -&gt; tensor -&gt; clip_score(image, prompt)</span>
</code></pre></div>

</details>
<hr />
<h2 id="5-gotchas">5. 常见陷阱与错误 (Gotchas)</h2>
<h3 id="51-srgb-vs-linear">5.1 颜色空间的“坑”：sRGB vs Linear</h3>
<ul>
<li><strong>问题</strong>：计算 MSE 或 LPIPS 时，渲染出的 PNG 是 sRGB（经过 Gamma 校正），而很多 PyTorch 里的图像 Tensor 假设是线性的或归一化到 <code>[-1, 1]</code> 的。</li>
<li><strong>后果</strong>：即使图片看起来一样，数值误差也很大。</li>
<li><strong>解决</strong>：确保渲染引擎输出和 Ground Truth 图像处于相同的色彩空间。通常建议在计算 Loss 前将图像都转换到 Linear RGB 空间，或统一使用 sRGB 并归一化到 <code>[0, 1]</code>。</li>
</ul>
<h3 id="52-stroke-width">5.2 Stroke-Width 的“消失魔术”</h3>
<ul>
<li><strong>问题</strong>：生成的 SVG 在浏览器里看正常，但喂给 CLIP 模型时得分极低。</li>
<li><strong>原因</strong>：CLIP 的预处理通常会将图片 Resize 到 <code>224x224</code>。如果你的 SVG 线条非常细（例如 1px on 1024px canvas），Resize 之后线条会因为抗锯齿算法变得极其模糊甚至消失。</li>
<li><strong>解决</strong>：在送入 CLIP 评测前，<strong>人为加粗</strong> SVG 的渲染线条（在渲染配置里设置最小 stroke-width），或者在渲染时使用更高的 DPI，然后进行高质量的 Downsampling。</li>
</ul>
<h3 id="53">5.3 默认值的诅咒</h3>
<ul>
<li><strong>问题</strong>：模型生成的 SVG 没有写 <code>fill</code> 属性。</li>
<li><strong>后果</strong>：SVG 标准规定默认 <code>fill="black"</code>。如果你的画布背景也是黑色，图形就“隐身”了。</li>
<li><strong>解决</strong>：评测代码必须具备<strong>鲁棒的默认值注入</strong>机制。例如，强制设置背景为白色，若元素未指定 fill/stroke，则显式设为默认颜色（如黑色 fill，无 stroke），以防渲染引擎行为不一致。</li>
</ul>
<h3 id="54-ghost-paths">5.4 幽灵路径 (Ghost Paths)</h3>
<ul>
<li><strong>问题</strong>：代码评分显示 <code>complexity</code> 很高，但图看起来很简单。</li>
<li><strong>原因</strong>：模型生成了大量 <code>opacity="0"</code>，<code>fill="none" stroke="none"</code>，或者位于视图外的路径。</li>
<li><strong>解决</strong>：在计算结构指标前，必须进行 <strong>Pruning（剪枝）</strong>。移除所有不可见的节点，否则你的复杂度惩罚会错误地惩罚“不可见”的垃圾代码，而不是惩罚“画得复杂”的图形。</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter12.html" class="nav-link prev">← 第 12 章：训练流程：预训练、指令微调、偏好对齐与有效性保障</a><a href="chapter14.html" class="nav-link next">第 14 章：SVG Animation：时间维度、交互与可控运动生成 →</a></nav>
        </main>
    </div>
</body>
</html>